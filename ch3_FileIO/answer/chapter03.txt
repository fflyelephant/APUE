3.1 read和write的无缓冲是指在用户层没有缓冲，在内核会有内核缓冲区，内核缓冲区主要是防止频繁调用磁盘IO，
	提高磁盘读写的效率
3.2 见 3-2mydup2.c 实现

3.3
	 		    文件表项1			   V节点表
			  ____________			 ____________
			 |文件状态指针|			|			 |   F_SETFD：设置文件描述符fd1的状态，只会影响fd1它自己
	fd1 ---->|____________|			|			 |	 F_SETFL：设置文件状态标志，这是修改到了文件表项，所以会影响到fd2
	fd2 ---->|_V节点指针__|-------->|			 |
			 |____________|			|			 |
			 						|			 |
	 		    文件表项2			|			 |
			  ____________			|			 |
			 |文件状态指针|			|			 |
			 |____________|			|			 |
	fd3 ---->|_V节点指针__|-------->|			 |
			 |____________|			|			 |
									|____________|

3.4 
	假设fd=1，则dup2(fd, 1)会返回1，且描述符1不会被关闭
	假设fd=3，三次dup2之后就会有4个文件描述符指向同一个文件表项，if语句将除0,1,2之外的fd关闭

3.5 
	./a.out > outfile 2>&1 (首先将a.out的标准输出重定向到outfile文件中，之后2>&1表示将原来的标准错误的输出定位到1上<此时的描述符1已经不是默认的终端了而是文件outfile>，也就是说原来的标准错误的输出将输出到outfile文件中)
	./a.out 2>&1 > outfile (和上面的只是顺序不同，先将标准错误重定向到1<此时的1还是默认的终端>，之后将1重定向到文件outfile)

3.6 
	在使用了O_APPEND标志之后仍然可以使用lseek从任意的位置开始读，但是没办法更新，因为write时不管之前lseek到了什么位置还是会执行两个动作: 
	(lseek到末尾 + write动作)，这两个动作在设置了O_APPEND之后是一个原子操作。